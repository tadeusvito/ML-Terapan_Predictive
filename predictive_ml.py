# -*- coding: utf-8 -*-
"""Predictive_ML.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vVjsMiNfexah6Lhi9VFLJEBJLZN0JBHO

# Data Loading
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
# %matplotlib inline
import seaborn as sns

# load the dataset
url = '/content/Updated_Hotel_Booking_Data.csv'
hotels = pd.read_csv(url)
hotels

"""# Exploratory Data Analysis

## Deskripsi Variabel
"""

hotels.info()

"""Dari output terlihat bahwa:

**Tipe data object (fitur kategori):**

*   Hotel Location
*   Season
*   Hotel Facilities
*   Booking Time

**Tipe data int64 & float64 (fitur numerik):**

Hotel Rating

*   Hotel Rating
*   Number of Nights
*   Number of Guests
*   Room Type
*   Price per NIght
*   Distance to Attractions

"""

hotels.describe()

"""## Handling Missing Value"""

hotels.isna().sum()

zero_value = (hotels == 0).sum()
zero_value

"""Pada kolom Booking Time, terdapat beberapa nilai yang menunjukkan angka 0. Hal ini dianggap wajar, karena angka 0 terjadi pada hari pemesanan, menunjukkan bahwa hotel tersebut mungkin baru menerima pemesanan pada hari yang sama."""

hotels[hotels['Booking Time'] == 0]

"""## Handling Data Duplicate"""

duplicate_rows = hotels[hotels.duplicated()]

if not duplicate_rows.empty:
    print("Duplicate Rows:")
    print(duplicate_rows)
else:
    print("No duplicate rows found.")

"""## Outliers"""

rows, cols = 6, 4
fig, axes = plt.subplots(rows, cols, figsize=(20, 30))

# Iterasi untuk membuat boxplot pada setiap kolom int64
for i, column in enumerate(hotels.columns):
    row, col = divmod(i, cols)
    sns.boxplot(ax=axes[row, col], x=hotels[column])
    axes[row, col].set_title(f'Box Plot of {column}')

# Menghapus subplot yang tidak terpakai jika jumlah kolom lebih sedikit daripada jumlah subplot
for j in range(len(hotels.columns), rows * cols):
    fig.delaxes(axes.flatten()[j])

plt.tight_layout()
plt.show()

"""Dari analisis box plot pada dataset ini, dapat disimpulkan bahwa sebagian besar data terdistribusi dengan baik tanpa adanya outlier yang signifikan. Beberapa nilai ekstrem terdeteksi pada sebagian kecil data, namun tidak cukup mencolok untuk mempengaruhi validitas analisis atau model prediksi secara keseluruhan. Secara umum, distribusi data terlihat stabil, dengan rentang nilai yang terpusat dan terjaga. Meskipun demikian, beberapa nilai ekstrem perlu diperhatikan lebih lanjut untuk memastikan konsistensi dan akurasi dalam analisis lebih mendalam.

## Univariate Analysis
"""

numerical_features = [
    'Hotel Rating', 'Number of Nights', 'Number of Guests', 'Distance to Attractions',
    'Booking Time', 'Price per Night'
]

categorical_features = [
    'Room Type', 'Hotel Location', 'Season', 'Hotel Facilities'
]

"""### Categorical Features"""

feature = categorical_features[0]
count = hotels[feature].value_counts()
percent = 100*hotels[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""**Insight:**

Dari grafik yang ditampilkan, dapat dilihat distribusi tipe kamar pada dataset ini. Tipe kamar Suite memiliki jumlah sampel terbesar, yaitu 205 dengan persentase 34,2%. Diikuti oleh Tipe kamar Single dengan 202 sampel (33,7%) dan Tipe kamar Double dengan 193 sampel (32,2%). Ini menunjukkan bahwa pembagian pemesanan kamar hampir merata antara ketiga jenis kamar, dengan sedikit lebih banyak pemesanan untuk tipe Suite dan Single dibandingkan dengan tipe Double.
"""

feature = categorical_features[1]
count = hotels[feature].value_counts()
percent = 100*hotels[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""**Insight:**

Grafik di atas menunjukkan distribusi data terkait lokasi hotel berdasarkan jumlah sampel dan persentase. Ketiga lokasi—Suburbs, City Center, dan Countryside—memiliki distribusi yang relatif seimbang, dengan sedikit perbedaan antara masing-masing. Suburbs memiliki jumlah sampel tertinggi (207) dan persentase terbesar (34.5%), diikuti oleh City Center (197 sampel, 32.8%) dan Countryside (196 sampel, 32.7%). Ini menunjukkan bahwa ada kecenderungan hampir seimbang dalam pemilihan lokasi hotel, meskipun Suburbs sedikit lebih dominan dalam hal jumlah sampel.
"""

feature = categorical_features[2]
count = hotels[feature].value_counts()
percent = 100*hotels[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""**Insight:**

Grafik di atas menunjukkan distribusi data berdasarkan musim, dengan dua kategori yaitu High Season dan Low Season. High Season memiliki jumlah sampel tertinggi (312) dan persentase terbesar (52%), sementara Low Season memiliki 288 sampel dan persentase 48%. Meskipun ada sedikit perbedaan antara keduanya, High Season memiliki sedikit lebih banyak sampel, yang mencerminkan sedikit lebih banyak aktivitas atau pengunjung selama musim tersebut.
"""

feature = categorical_features[3]
count = hotels[feature].value_counts()
percent = 100*hotels[feature].value_counts(normalize=True)
df = pd.DataFrame({'jumlah sampel':count, 'persentase':percent.round(1)})
print(df)
count.plot(kind='bar', title=feature);

"""### Numerical Features"""

hotels.hist(bins=50, figsize=(20,15))
plt.show()

"""**Insight:**


*   Hotel Rating: Sebagian besar hotel memiliki rating antara 3 hingga 5, dengan rating 4 menjadi yang paling umum. Ini menunjukkan bahwa banyak tamu cenderung memilih hotel dengan kualitas yang baik.
*   Booking Time: Waktu pemesanan bervariasi, dengan banyak pemesanan dilakukan dalam rentang 0 hingga 30 hari sebelum kedatangan. Ini menunjukkan bahwa tamu cenderung melakukan pemesanan dalam waktu dekat, mungkin karena fleksibilitas dalam perjalanan.
*   Number of Nights: Tamu cenderung menginap antara 1 hingga 14 malam, dengan frekuensi yang cukup merata. Ini menunjukkan bahwa ada variasi dalam durasi menginap, mungkin tergantung pada tujuan perjalanan.
*  Number of Guests: Jumlah tamu bervariasi, tetapi sebagian besar hotel tampaknya memiliki kapasitas untuk menampung lebih dari 2 tamu. Ini menunjukkan bahwa hotel mungkin lebih sering digunakan untuk kelompok atau keluarga.
*   Price per Night: Harga per malam menunjukkan distribusi yang bervariasi, dengan banyak hotel berada di kisaran harga 200 hingga 400. Ini menunjukkan adanya pilihan harga yang beragam, memungkinkan tamu untuk memilih sesuai anggaran mereka.
*   Distance to Attractions: Jarak ke atraksi bervariasi, dengan beberapa tamu memilih hotel yang lebih dekat ke pusat atraksi. Ini menunjukkan pentingnya lokasi dalam pemilihan hotel.

## Multivariate Analysis

### Categorical Features
"""

import seaborn as sns
import matplotlib.pyplot as plt

# Menentukan kolom kategorikal
cat_features = hotels.select_dtypes(include='object').columns.to_list()

# Menentukan jumlah baris dan kolom secara dinamis
n_cols = 3  # Jumlah kolom dalam grid
n_rows = -(-len(cat_features) // n_cols)  # Hitung jumlah baris (ceiling division)

# Membuat grid subplots
fig, axes = plt.subplots(nrows=n_rows, ncols=n_cols, figsize=(18, 5 * n_rows))
axes = axes.flatten()  # Meratakan grid untuk iterasi

# Membuat plot untuk setiap kolom kategorikal
for i, col in enumerate(cat_features):
    # Changed 'Price (£)' to 'Y_harga_unit'
    sns.barplot(
        x=col,
        y="Price per Night",  # Use the correct column name for price
        data=hotels,
        ax=axes[i],
        palette="Set3",
        ci=None  # Interval kepercayaan dihilangkan untuk kejelasan
    )
    axes[i].set_title(f"Rata-rata 'Price per Night' terhadap {col}", fontsize=12)
    axes[i].tick_params(axis='x', rotation=45)  # Membuat label x miring
    axes[i].set_xlabel('')
    axes[i].set_ylabel('Rata-rata Harga')

# Menghapus subplot kosong (jika ada)
for j in range(len(cat_features), len(axes)):
    fig.delaxes(axes[j])

# Menyesuaikan tata letak
plt.tight_layout()
plt.show()

"""**Insight:**
*   Room Type: Rata-rata harga untuk berbagai jenis kamar (Single, Suite, Double) tampak cukup seragam. Ini menunjukkan bahwa tidak ada perbedaan harga yang signifikan antara jenis kamar yang berbeda. Hal ini bisa berarti bahwa hotel tersebut memiliki strategi harga yang konsisten untuk semua jenis kamar.
*   Hotel Location: Rata-rata harga untuk lokasi hotel (Countryside, City Center, Suburbs) juga menunjukkan pola yang serupa. Ini menunjukkan bahwa lokasi tidak terlalu mempengaruhi harga, atau hotel mungkin memiliki kebijakan harga yang seragam di semua lokasi.
*   Season: Terdapat perbedaan yang jelas antara harga di musim tinggi dan musim rendah. Harga di musim tinggi lebih tinggi dibandingkan dengan musim rendah, yang sesuai dengan ekspektasi umum bahwa permintaan akan akomodasi meningkat selama musim puncak.
*   Hotel Facilities:Rata-rata harga untuk fasilitas hotel (Pool, Restaurant, Spa, Gym, Free Wi-Fi) menunjukkan variasi yang lebih besar. Fasilitas seperti Spa dan Gym mungkin menarik lebih banyak tamu, sehingga harga bisa lebih tinggi. Namun, semua fasilitas tampak memiliki harga yang relatif seimbang, menunjukkan bahwa hotel mungkin menawarkan nilai yang baik untuk berbagai fasilitas.

### Numerical Features
"""

sns.pairplot(hotels, diag_kind = 'kde')

"""**Insight:**
*   Kualitas vs. Harga: Tamu cenderung memilih hotel dengan rating lebih tinggi meskipun harganya lebih mahal.
*   Durasi Menginap: Banyak tamu memilih untuk menginap dalam waktu singkat, tetapi ada juga yang merencanakan perjalanan jauh-jauh hari.
*   Variasi Harga: Harga per malam bervariasi secara signifikan, dan ini mungkin dipengaruhi oleh rating hotel dan waktu pemesanan.




"""

numerical_features = [col for col in numerical_features if col in hotels.columns]

plt.figure(figsize=(10, 8))
correlation_matrix = hotels[numerical_features].corr(method='spearman').round(2)

# Untuk menampilkan nilai di dalam kotak
sns.heatmap(data=correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5)
plt.title("Correlation Matrix untuk Fitur Numerik", size=20)
plt.show()

"""**Insight:**


1.   **Korelasi Positif Kuat:**
*   Terdapat korelasi positif yang kuat (nilai korelasi mendekati 1) antara "Number of Nights" dan "Price per Night". Ini menunjukkan bahwa semakin lama tamu menginap, semakin tinggi harga per malamnya.
*   Juga terdapat korelasi positif yang kuat antara "Booking Time" dan "Price per Night". Ini mengindikasikan bahwa pemesanan yang dilakukan lebih awal cenderung memiliki harga per malam yang lebih tinggi.

2.   **Korelasi Positif Sedang:**
*   Terdapat korelasi positif sedang (nilai korelasi sekitar 0,5-0,7) antara "Number of Guests" dan "Number of Nights", serta "Number of Guests" dan "Price per Night". Ini menunjukkan bahwa semakin banyak tamu, semakin lama mereka menginap dan semakin tinggi harga per malamnya.


3.  **Korelasi Negatif Lemah:**
*  Terdapat korelasi negatif lemah (nilai korelasi sekitar -0,2) antara "Hotel Rating" dan "Number of Nights", serta "Hotel Rating" dan "Number of Guests". Ini mengindikasikan bahwa hotel dengan rating lebih tinggi cenderung memiliki tamu yang menginap lebih singkat dan dengan jumlah tamu yang lebih sedikit.


4.   **Korelasi Hampir Nol:**
*   Korelasi antara "Distance to Attractions" dan sebagian besar variabel lainnya mendekati nol. Ini menunjukkan bahwa jarak ke atraksi tidak memiliki hubungan yang signifikan dengan variabel-variabel lain dalam dataset.

## Menambahkan Fitur

Menambahkan fitur baru yang merepresentasikan interaksi antara beberapa fitur dapat membantu meningkatkan pemahaman tentang hubungan kompleks yang mempengaruhi harga. Dengan mengeksplorasi kombinasi dan rasio antar fitur, kita dapat mengungkap pola-pola yang sebelumnya tidak terlihat, sehingga dapat meningkatkan kemampuan memprediksi atau menjelaskan harga secara lebih akurat
"""

# Membuat fitur baru berdasarkan interaksi antara beberapa fitur
hotels['Nights_Guests_Interaction'] = hotels['Number of Nights'] * hotels['Number of Guests']
hotels['Distance_Booking_Ratio'] = hotels['Distance to Attractions'] / (hotels['Booking Time'] + 1)  # Untuk menghindari pembagian dengan 0

# Menghitung korelasi kembali setelah penambahan fitur baru
new_numerical_features = numerical_features + ['Nights_Guests_Interaction', 'Distance_Booking_Ratio']

# Menghitung matriks korelasi
correlation_matrix_new = hotels[new_numerical_features].corr()

# Visualisasi korelasi dalam bentuk heatmap yang baru
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix_new, annot=True, cmap='coolwarm', fmt='.2f', linewidths=0.5)
plt.title('Updated Correlation Matrix untuk Fitur Numerik', fontsize=14)
plt.show()

"""**Insight**

1. **Korelasi Positif yang Kuat:**  
   - **Number of Nights dan Price per Night** memiliki korelasi yang sangat tinggi (0.86), menunjukkan bahwa semakin banyak malam yang dipesan, semakin tinggi harga per malam yang dikenakan. Ini mungkin mencerminkan kebijakan harga yang lebih tinggi untuk pemesanan jangka panjang.  
   - **Number of Guests** juga menunjukkan korelasi positif yang signifikan dengan **Number of Nights (0.73)** dan **Price per Night (0.85)**, menunjukkan bahwa pemesanan untuk lebih banyak tamu cenderung berlangsung lebih lama dan dengan harga yang lebih tinggi.  

2. **Korelasi Negatif:**  
   - **Booking Time dan Distance Booking Ratio** memiliki korelasi negatif yang cukup kuat (-0.52), menunjukkan bahwa semakin jauh waktu pemesanan dari tanggal kedatangan, semakin kecil kemungkinan tamu memilih hotel yang jauh dari atraksi. Ini menunjukkan bahwa tamu lebih cenderung memesan hotel yang dekat dengan atraksi saat mereka melakukan pemesanan mendekati waktu kedatangan.  

3. **Korelasi Lemah:**  
   - Sebagian besar fitur lainnya menunjukkan korelasi yang lemah, dengan nilai di sekitar 0.1 hingga 0.3. Misalnya, **Hotel Rating dan Distance to Attractions** memiliki korelasi positif yang sangat rendah (0.05), menunjukkan bahwa tidak ada hubungan yang signifikan antara rating hotel dan jarak ke atraksi.  

4. **Interaksi Tamu dan Malam:**  
   - **Nights_Guests_Interaction** menunjukkan korelasi positif dengan **Number of Nights (0.63)** dan **Number of Guests (0.63)**, yang menunjukkan bahwa interaksi antara jumlah malam dan jumlah tamu berkontribusi pada pemesanan yang lebih lama dan lebih banyak tamu.

#Data Preparation

##Encode Fitur Kategori
"""

from sklearn.preprocessing import OneHotEncoder

# Check if categorical columns exist before applying one-hot encoding
categorical_features = ['Room Type', 'Hotel Location', 'Season', 'Hotel Facilities']
existing_categorical_features = [col for col in categorical_features if col in hotels.columns]

# Apply one-hot encoding only to existing categorical features
for feature in existing_categorical_features:
    hotels = pd.concat([hotels, pd.get_dummies(hotels[feature], prefix=feature)], axis=1)

# Drop original categorical columns that were encoded
hotels.drop(existing_categorical_features, axis=1, inplace=True, errors='ignore')

hotels.head()

"""##PCA"""

sns.pairplot(hotels[['Number of Nights','Nights_Guests_Interaction']], plot_kws={"s": 2});

from sklearn.decomposition import PCA

pca = PCA(n_components=2, random_state=123)
pca.fit(hotels[['Number of Nights','Nights_Guests_Interaction']])
princ_comp = pca.transform(hotels[['Number of Nights','Nights_Guests_Interaction']])

pca.explained_variance_ratio_.round(2)

from sklearn.decomposition import PCA
pca = PCA(n_components=1, random_state=123)
pca.fit(hotels[['Number of Nights','Nights_Guests_Interaction']])
hotels['Efficiency'] = pca.transform(hotels.loc[:, ('Number of Nights','Nights_Guests_Interaction')]).flatten()
hotels.drop(['Number of Nights','Nights_Guests_Interaction'], axis=1, inplace=True)

hotels.head()

"""## Train Test Split"""

from sklearn.model_selection import train_test_split

X = hotels.drop(["Price per Night"],axis =1)
y = hotels["Price per Night"]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 123)

print(f'Total # of sample in whole dataset: {len(X)}')
print(f'Total # of sample in train dataset: {len(X_train)}')
print(f'Total # of sample in test dataset: {len(X_test)}')

"""## Standarisasi"""

from sklearn.preprocessing import StandardScaler

# Update numerical_features to exclude dropped columns
numerical_features = [
    'Hotel Rating', 'Number of Guests', 'Distance to Attractions',
    'Booking Time', 'Distance_Booking_Ratio', 'Efficiency'  # Include 'Efficiency' if it's a numerical feature
]

scaler = StandardScaler()

# Select only the existing numerical features for scaling
scaler.fit(X_train[numerical_features])
X_train[numerical_features] = scaler.transform(X_train.loc[:, numerical_features])

X_train[numerical_features].head()

X_train[numerical_features].describe().round(3)

"""# Model Development"""

# Siapkan dataframe untuk analisis model
models = pd.DataFrame(index=['train_mse', 'test_mse'],
                      columns=['KNN', 'RandomForest', 'Boosting'])

"""## KNN Model"""

from sklearn.neighbors import KNeighborsRegressor
from sklearn.metrics import mean_squared_error

knn = KNeighborsRegressor(n_neighbors=13)
knn.fit(X_train, y_train)

models.loc['train_mse','knn'] = mean_squared_error(y_pred = knn.predict(X_train), y_true=y_train)

"""## Random Forest Model"""

# Impor library yang dibutuhkan
from sklearn.ensemble import RandomForestRegressor

# buat model prediksi
RF = RandomForestRegressor(n_estimators=100, max_depth=10, random_state=55, n_jobs=-1)
RF.fit(X_train, y_train)

models.loc['train_mse','RandomForest'] = mean_squared_error(y_pred=RF.predict(X_train), y_true=y_train)

"""## Ada Boosting Model

"""

from sklearn.ensemble import AdaBoostRegressor

boosting = AdaBoostRegressor(n_estimators=250,
                             learning_rate=0.01,
                             random_state=50)

boosting.fit(X_train, y_train)
models.loc['train_mse','Boosting'] = mean_squared_error(y_pred=boosting.predict(X_train), y_true=y_train)

"""# Evaluasi"""

X_test[numerical_features] = scaler.transform(X_test.loc[:, numerical_features])
X_test[numerical_features].head()

# Buat variabel mse yang isinya adalah dataframe nilai mse data train dan test pada masing-masing algoritma
mse = pd.DataFrame(columns=['train', 'test'], index=['KNN','RF','Boosting'])

# Buat dictionary untuk setiap algoritma yang digunakan
model_dict = {'KNN': knn, 'RF': RF, 'Boosting': boosting}

# Hitung Mean Squared Error masing-masing algoritma pada data train dan test
for name, model in model_dict.items():
    mse.loc[name, 'train'] = mean_squared_error(y_true=y_train, y_pred=model.predict(X_train))/1e3
    mse.loc[name, 'test'] = mean_squared_error(y_true=y_test, y_pred=model.predict(X_test))/1e3

# Panggil mse
mse

fig, ax = plt.subplots()
mse.sort_values(by='test', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

prediksi = X_test.iloc[:10].copy()
pred_dict = {'y_true':y_test[:10]}
for name, model in model_dict.items():
    pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)

pd.DataFrame(pred_dict)

gridtuning = pd.DataFrame(index=['KNN', 'RF', 'Adaboost'], columns=['train_mse', 'test_mse'])

from sklearn.model_selection import GridSearchCV

param_grid_knn = {
    'n_neighbors': [3, 5, 7, 9, 11, 13, 15]
}

knn = KNeighborsRegressor()

grid_search_knn = GridSearchCV(knn, param_grid_knn, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid_search_knn.fit(X_train, y_train)

gridtuning.loc['KNN', 'train_mse'] = mean_squared_error(y_pred=grid_search_knn.predict(X_train), y_true=y_train)
gridtuning.loc['KNN', 'test_mse'] = mean_squared_error(y_pred=grid_search_knn.predict(X_test), y_true=y_test)

param_grid_rf = {
    'n_estimators': [10, 50, 100, 200],
    'max_depth': [None, 10, 20, 30],
    'min_samples_split': [2, 5, 10]
}

rf = RandomForestRegressor(random_state=35, n_jobs=-1)

grid_search_rf = GridSearchCV(rf, param_grid_rf, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid_search_rf.fit(X_train, y_train)

gridtuning.loc['RF', 'train_mse'] = mean_squared_error(y_pred=grid_search_rf.predict(X_train), y_true=y_train)
gridtuning.loc['RF', 'test_mse'] = mean_squared_error(y_pred=grid_search_rf.predict(X_test), y_true=y_test)

param_grid_ada = {
    'n_estimators': [50, 100, 200, 300],
    'learning_rate': [0.01, 0.1, 1.0]
}

ada = AdaBoostRegressor(random_state=42)

grid_search_ada = GridSearchCV(ada, param_grid_ada, cv=5, scoring='neg_mean_squared_error', n_jobs=-1)
grid_search_ada.fit(X_train, y_train)

gridtuning.loc['Adaboost', 'train_mse'] = mean_squared_error(y_pred=grid_search_ada.predict(X_train), y_true=y_train)
gridtuning.loc['Adaboost', 'test_mse'] = mean_squared_error(y_pred=grid_search_ada.predict(X_test), y_true=y_test)

gridtuning

fig, ax = plt.subplots()
gridtuning.sort_values(by='test_mse', ascending=False).plot(kind='barh', ax=ax, zorder=3)
ax.grid(zorder=0)

prediksi = X_test.iloc[:10].copy()
pred_dict = {'y_true':y_test[:10]}
for name, model in model_dict.items():
    pred_dict['prediksi_'+name] = model.predict(prediksi).round(1)

pd.DataFrame(pred_dict)